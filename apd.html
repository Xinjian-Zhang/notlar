<!DOCTYPE html>
<html>
<head>
<title>ap</title>
<meta charset = "utf-8"/>
<style>body{margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',Heiti,sans-serif,SimSun,serif}ul{list-style:disc outside; padding-bottom: 4px;}li{line-height: 27px; list-style: disc;font-size:19px;padding: 2px 0px;}blockquote p {color: #252525;font-family: 'EB Garamond', serif;font-size: 24px;}blockquote {background-color: #dce7e7 !important;border-left: 5px solid #219895 !important;margin: 2px 0 !important;padding: 1px 0px 1px 0px;}img{max-width:1024px;padding: 5px 0px;}.annot{padding: 15px 0px;border-bottom-style:solid;}.tag{color:blue;font-size:15px;}</style></head>
<body>
<div style="font-size: 22px; padding: 0 15px 0; ">
<div style = "padding-bottom: 0px"><h2>ap</h2></div>
<div style = "background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div>
</div>
<ul><li><blockquote><p>Coursework 4 JSON data interchange syntax <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=0&x=193&y=135&id=4&uuid=60a74b6d20ae764c30ad3492eb1eb9b1>[P0]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">部分实现ECMA-404标准（一种用于数据交换的结构化文本语法）的应用</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">主要任务：</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">1.定义一个合适的数据类型来表示这种数据交换格式的抽象语法树</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">2.并定义一些对这个表示进行操作的函数。</p></body></div></li><li><blockquote><p>JSON data interchange syntax <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=0&x=242&y=135&id=3&uuid=da11ff62b0920832d69c4a9a187f84da>[P0]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">JSON 数据交换语法</p></body></div></li><li><h3>目标：定义Ecma类型来表示ECMA-404交换格式的可能值，并创建一些基础函数来构建ECMA-404数据结构。</h3><blockquote><p>Task 1 <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=0&x=58&y=375&id=5&uuid=362b0e0df1f6b7f8017a12a062e5df29>[P0]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义Ecma类型来表示ECMA-404交换格式的可能值，并创建一些基础函数来构建ECMA-404数据结构。</p></body></div></li><li><blockquote><p>let mkObject () = Object[] <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=0&x=127&y=688&id=6&uuid=905f80bc3fcadd8fa6811125e47e831f>[P0]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkObject ()</span>：定义一个名为<span style=" font-family:'Courier New';">mkObject</span>的函数，没有参数（除了隐含的<span style=" font-family:'Courier New';">unit</span>类型参数）。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= Object []</span>：函数返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，此处为<span style=" font-family:'Courier New';">Object</span>构造器，带有一个空列表（<span style=" font-family:'Courier New';">[]</span>），表示一个空的JSON对象。</li></ul></body></div></li><li><blockquote><p>let mkNumber f = Number f <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=124&y=76&id=7&uuid=c41edf8f9a6864bc90c4333c365d7f3b>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkNumber f</span>：定义一个名为<span style=" font-family:'Courier New';">mkNumber</span>的函数，接受一个浮点数<span style=" font-family:'Courier New';">f</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= Number f</span>：返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，使用<span style=" font-family:'Courier New';">Number</span>构造器，其值为<span style=" font-family:'Courier New';">f</span>。</li></ul></body></div></li><li><blockquote><p>let mkBool b = Bool b <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=113&y=174&id=10&uuid=d0c9dad19bd9256038c11a4ce38cb08b>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkBool b</span>：定义一个名为<span style=" font-family:'Courier New';">mkBool</span>的函数，接受一个布尔值<span style=" font-family:'Courier New';">b</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= Bool b</span>：返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，使用<span style=" font-family:'Courier New';">Bool</span>构造器，其值为<span style=" font-family:'Courier New';">b</span>。</li></ul></body></div></li><li><h3>let mkString s：定义一个名为mkString的函数，接受一个字符串s作为参数。
= String s：返回一个Ecma类型的值，使用String构造器，其值为s。</h3><blockquote><p>let mkString s = String s <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=124&y=273&id=11&uuid=974fb50c2eb2df95b71f0b0889a4a847>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkString s</span>：定义一个名为<span style=" font-family:'Courier New';">mkString</span>的函数，接受一个字符串<span style=" font-family:'Courier New';">s</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= String s</span>：返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，使用<span style=" font-family:'Courier New';">String</span>构造器，其值为<span style=" font-family:'Courier New';">s</span>。</li></ul></body></div></li><li><blockquote><p>let mkArray ele = Array ele <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=130&y=371&id=12&uuid=5bcf802a44d19537b4ed98b7d61b094b>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkArray ele</span>：定义一个名为<span style=" font-family:'Courier New';">mkArray</span>的函数，接受一个<span style=" font-family:'Courier New';">Ecma</span>类型列表<span style=" font-family:'Courier New';">ele</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= Array ele</span>：返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，使用<span style=" font-family:'Courier New';">Array</span>构造器，其值为<span style=" font-family:'Courier New';">ele</span>。</li></ul></body></div></li><li><blockquote><p>let mkNull () = Null <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=110&y=469&id=13&uuid=fbdd6be4e683e0fb198d35776f8ed048>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let mkNull ()</span>：定义一个名为<span style=" font-family:'Courier New';">mkNull</span>的函数，没有参数（除了隐含的<span style=" font-family:'Courier New';">unit</span>类型参数）。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">= Null</span>：返回一个<span style=" font-family:'Courier New';">Ecma</span>类型的值，使用<span style=" font-family:'Courier New';">Null</span>构造器，表示JSON中的<span style=" font-family:'Courier New';">null</span>值。</li></ul></body></div></li><li><blockquote><p>Task 2 <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=59&y=514&id=14&uuid=f7967b2104cd65f70d294b3cdfb00361>[P1]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义两个函数来修改ECMA对象和数组表示。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：为对象添加键值对，为数组添加元素。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let addNameValue (n, v) e</span>：如果<span style=" font-family:'Courier New';">e</span>是对象，将键值对<span style=" font-family:'Courier New';">(n, v)</span>添加到该对象中，否则保持<span style=" font-family:'Courier New';">e</span>不变。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let addValue v e</span>：如果<span style=" font-family:'Courier New';">e</span>是数组，将值<span style=" font-family:'Courier New';">v</span>添加到数组中，否则保持<span style=" font-family:'Courier New';">e</span>不变。</li></ul></body></div></li><li><h3>addNameValue (n, v)
e</h3><blockquote><img src = "apd/41ed818d799b8fb6bb4c3a93ceffcb35.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=186&y=671&id=15&uuid=f317ae36675885b58154303411ea9bfa>[P1]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let addNameValue (n, v) e</span>：定义一个名为<span style=" font-family:'Courier New';">addNameValue</span>的函数，接受一个键值对<span style=" font-family:'Courier New';">(n, v)</span>和一个<span style=" font-family:'Courier New';">Ecma</span>类型的值<span style=" font-family:'Courier New';">e</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查<span style=" font-family:'Courier New';">e</span>的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object obj -&gt; Object (obj @ [(n, v)])</span>：如果<span style=" font-family:'Courier New';">e</span>是一个<span style=" font-family:'Courier New';">Object</span>，将键值对<span style=" font-family:'Courier New';">(n, v)</span>添加到对象列表<span style=" font-family:'Courier New';">obj</span>中，并返回新的<span style=" font-family:'Courier New';">Object</span>。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| _ -&gt; e</span>：如果<span style=" font-family:'Courier New';">e</span>不是一个<span style=" font-family:'Courier New';">Object</span>，保持<span style=" font-family:'Courier New';">e</span>不变。</li></ul></body></div></li><li><h3>addValue v e</h3><blockquote><img src = "apd/2b3e5956d6b82f10baf5a5e9663c4ec6.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=1&x=291&y=882&id=16&uuid=7dcaf6e9f423110a6581ccacd14a534c>[P1]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let addValue v e</span>：定义一个名为<span style=" font-family:'Courier New';">addValue</span>的函数，接受一个<span style=" font-family:'Courier New';">Ecma</span>类型的值<span style=" font-family:'Courier New';">v</span>和另一个<span style=" font-family:'Courier New';">Ecma</span>类型的值<span style=" font-family:'Courier New';">e</span>作为参数。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查<span style=" font-family:'Courier New';">e</span>的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array arr -&gt; Array (arr @ [v])</span>：如果<span style=" font-family:'Courier New';">e</span>是一个<span style=" font-family:'Courier New';">Array</span>，将值<span style=" font-family:'Courier New';">v</span>添加到数组列表<span style=" font-family:'Courier New';">arr</span>中，并返回新的<span style=" font-family:'Courier New';">Array</span>。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| _ -&gt; e</span>：如果<span style=" font-family:'Courier New';">e</span>不是一个<span style=" font-family:'Courier New';">Array</span>，保持<span style=" font-family:'Courier New';">e</span>不变。</li></ul></body></div></li><li><h3>Task3 Count Value</h3><blockquote><img src = "apd/9c8e69b6ab38510a4046be8d86ef0d10.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=2&x=293&y=314&id=18&uuid=4ef90d9caa25e73e69cc46e0fa5829d9>[P2]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义一个函数来计算给定ECMA表示中的值数量。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：递归地遍历对象或数组，并计算其中的值。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec countValues (e: Ecma) : int</span>：根据<span style=" font-family:'Courier New';">e</span>的类型（对象、数组或其他），递归地计算其中的值数量。</li></ul></body></div></li><li><h3>countValues : Ecma -> int</h3><blockquote><img src = "apd/410af229d4196366c0ba8833089c1722.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=2&x=249&y=474&id=19&uuid=8414173846cd30d65379b9218fca1132>[P2]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec countValues (e: Ecma) : int</span>：定义一个递归函数<span style=" font-family:'Courier New';">countValues</span>，接受一个<span style=" font-family:'Courier New';">Ecma</span>类型的值<span style=" font-family:'Courier New';">e</span>作为参数，返回一个整数。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查<span style=" font-family:'Courier New';">e</span>的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object obj -&gt;</span>：如果<span style=" font-family:'Courier New';">e</span>是一个对象，计算对象中所有值的数量。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">1 + List.sumBy (fun (_, v) -&gt; countValues v) obj</span>：对于对象中的每个键值对，递归调用<span style=" font-family:'Courier New';">countValues</span>计算值的数量，然后将这些数量加起来，并加上1（代表对象本身）。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array arr -&gt;</span>：如果<span style=" font-family:'Courier New';">e</span>是一个数组，计算数组中所有值的数量。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">1 + List.sumBy countValues arr</span>：对于数组中的每个元素，递归调用<span style=" font-family:'Courier New';">countValues</span>计算其值的数量，然后将这些数量加起来，并加上1（代表数组本身）。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| _ -&gt; 1</span>：对于其他类型（数字、布尔值、字符串、空值），它们自身就是一个值，因此返回1。</li></ul></body></div></li><li><h3>List.sumBy</h3><blockquote><img src = "apd/0337a54668272c4f8fd04ea65dd439e9.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=2&x=243&y=475&id=20&uuid=4e1c9a1700c4368eb48fbd8472e99d54>[P2]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">List.sumBy</span> 是 F# 中的一个函数，它的作用是对列表中的每个元素应用一个函数，并将结果相加。在你的代码中，<span style=" font-family:'Courier New';">List.sumBy (fun (_, v) -&gt; countValues v) obj</span> 的作用是对 <span style=" font-family:'Courier New';">obj</span> 中的每个键值对，取值部分应用 <span style=" font-family:'Courier New';">countValues</span> 函数，并将结果相加。这样做的效果是计算对象中嵌套的值的总数。</p></body></div></li><li><h3>Task4 值的完整路径</h3><blockquote><img src = "apd/5234d73430cfd737b3ce4cfc6cd07a0b.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=2&x=298&y=668&id=22&uuid=29263a7b4283e034bb88e76550ed3ffb>[P2]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义一个函数来计算给定ECMA表示中所有值的完整路径。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：递归地遍历对象或数组，并记录到每个值的路径。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec paths e</span>：递归函数，为对象或数组中的每个元素生成路径。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let listPaths (ecma: Ecma) : List&lt;Path&gt;</span>：使用<span style=" font-family:'Courier New';">paths</span>函数生成给定ECMA表示中所有值的路径列表。</li></ul></body></div></li><li><h3>注意事项</h3><blockquote><img src = "apd/0ab39292cce9b420e9a1a5ca439b23fb.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=3&x=302&y=498&id=24&uuid=1220f15be7cf8baac53a461d30798fff>[P3]</a></blockquote><div class="annot">数组中（子）值的路径遵循数组中元素的顺序<br/><br/>对象中值的路径遵循将值添加到对象的顺序（最近添加的出现在最后）</div></li><li><h3>listPaths : Ecma -> Path list</h3><blockquote><img src = "apd/a7545f182250486efe1212807fffe5d4.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=4&x=268&y=183&id=25&uuid=7c688ed17ce8048ddbb50e3603c6d869>[P4]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec paths e</span>：定义一个递归辅助函数<span style=" font-family:'Courier New';">paths</span>，用于计算给定ECMA表示中所有值的路径。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查<span style=" font-family:'Courier New';">e</span>的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object obj -&gt;</span>：如果<span style=" font-family:'Courier New';">e</span>是一个对象，计算对象中所有值的路径。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">List.collect</span>遍历对象的每个键值对。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果值是对象或数组，递归调用<span style=" font-family:'Courier New';">paths</span>并将当前键名添加到每个返回的路径前面，构造新的路径。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果值是其他类型，返回仅包含当前键名的路径。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array ele -&gt;</span>：如果<span style=" font-family:'Courier New';">e</span>是一个数组，计算数组中所有值的路径。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">List.collect</span>遍历数组的每个元素，并递归调用<span style=" font-family:'Courier New';">paths</span>。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| _ -&gt; []</span>：对于其他类型，不包含任何子路径，返回空列表。</li></ul></body></div></li><li><h3>List.collect, List.map \></h3><blockquote><img src = "apd/26fa62f8e9f7555552186fdbc9f60cc2.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=4&x=258&y=184&id=26&uuid=24f2169cba29dd8f9531cbf43376646e>[P4]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';"><br />List.collect</span>：在 F# 中，<span style=" font-family:'Courier New';">List.collect</span> 是一个用于将函数应用到列表的每个元素并收集结果的函数。它会将每个元素的映射结果展平成一个单一的列表。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">List.map</span>：<span style=" font-family:'Courier New';">List.map</span> 是 F# 中的函数，它接受一个函数和一个列表，并将该函数应用于列表中的每个元素，返回一个包含映射结果的新列表。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">|&gt;</span>：这是 F# 中的管道操作符，它用于将左侧表达式的结果传递给右侧的函数。</p></body></div></li><li><h3>Task 5 
生成给定ECMA表示的字符串表示形式</h3><blockquote><img src = "apd/172b537a85a3ecb6a259e34bc077db86.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=4&x=294&y=393&id=28&uuid=084cad03d78e41def8c088abe0dbcb93>[P4]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义一个函数来生成给定ECMA表示的字符串表示形式。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：递归地遍历ECMA表示，并根据其类型转换为字符串。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec show (e: Ecma) : string</span>：根据<span style=" font-family:'Courier New';">e</span>的类型（空值、布尔值、数字、字符串、数组或对象），生成其字符串表示。</li></ul></body></div></li><li><h3>show : Ecma -> string</h3><blockquote><img src = "apd/453358c4b5b181449be493178c2d0ca3.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=4&x=293&y=558&id=29&uuid=cd14e280b04562a205a57307e9713895>[P4]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec show (e: Ecma) : string</span>：定义了一个递归函数 <span style=" font-family:'Courier New';">show</span>，它接受一个 <span style=" font-family:'Courier New';">Ecma</span> 类型的数据 <span style=" font-family:'Courier New';">e</span> 并返回一个字符串。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查 <span style=" font-family:'Courier New';">e</span> 的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Null -&gt; &quot;null&quot;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Null</span> 类型，则返回字符串 <span style=" font-family:'Courier New';">&quot;null&quot;</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Bool b -&gt; b.ToString().ToLower()</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Bool</span> 类型，将布尔值 <span style=" font-family:'Courier New';">b</span> 转换为小写的字符串形式（例如，<span style=" font-family:'Courier New';">true</span> 转换为 <span style=" font-family:'Courier New';">&quot;true&quot;</span>）。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Number n -&gt; n.ToString()</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Number</span> 类型，将数字 <span style=" font-family:'Courier New';">n</span> 转换为字符串形式。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| String s -&gt; &quot;\&quot;&quot; + s + &quot;\&quot;&quot;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">String</span> 类型，将字符串 <span style=" font-family:'Courier New';">s</span> 用引号包围，形成 JSON 字符串。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array arr -&gt; &quot;[&quot; + String.concat &quot;,&quot; (List.map show arr) + &quot;]&quot;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Array</span> 类型，递归地对数组的每个元素调用 <span style=" font-family:'Courier New';">show</span> 函数，然后将结果用逗号连接，并用方括号包围。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object obj -&gt; &quot;{&quot; + String.concat &quot;,&quot; (List.map (fun (n, v) -&gt; &quot;\&quot;&quot; + n + &quot;\&quot;:&quot; + show v) obj) + &quot;}&quot;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Object</span> 类型，对对象中的每个键值对进行处理，递归地对值调用 <span style=" font-family:'Courier New';">show</span> 函数，并将键和值以 <span style=" font-family:'Courier New';">&quot;key&quot;:&quot;value&quot;</span> 形式组合，最后用逗号连接并用花括号包围。</li></ul></body></div></li><li><h3>Task 6 删除指定路径的值</h3><blockquote><img src = "apd/c38e81654657cc55b1467648e5d83e55.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=4&x=294&y=801&id=30&uuid=7a2ed1b8de19908d7821483aae3c4a39>[P4]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义一个函数来从给定的ECMA表示中删除指定路径的值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：沿着指定路径遍历ECMA表示，移除对应的值。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec delAtPath p (e: Ecma)</span>：递归地沿路径<span style=" font-family:'Courier New';">p</span>遍历ECMA表示<span style=" font-family:'Courier New';">e</span>，删除对应值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let delete ps e</span>：使用<span style=" font-family:'Courier New';">delAtPath</span>函数删除<span style=" font-family:'Courier New';">e</span>中所有指定路径<span style=" font-family:'Courier New';">ps</span>上的值。</li></ul></body></div></li><li><h3>delete : Path list -> Ecma -> Ecma</h3><blockquote><img src = "apd/a4ac6f1760f55adaf58ea79becda0fee.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=5&x=300&y=321&id=32&uuid=507f28d62e0e7fb5d7969d7b26554da2>[P5]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec delAtPath p (e: Ecma)</span>：定义了一个递归函数 <span style=" font-family:'Courier New';">delAtPath</span>，用于删除路径 <span style=" font-family:'Courier New';">p</span> 上的值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查 <span style=" font-family:'Courier New';">e</span> 的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object obj -&gt;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Object</span> 类型，处理对象。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match p with</span>：再次使用模式匹配来检查路径 <span style=" font-family:'Courier New';">p</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| [] -&gt; Object obj</span>：如果路径为空，不进行任何操作。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| [key] -&gt;</span>：如果路径只有一个键，移除该键。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let filteredPairs = List.filter (fun (curK, _) -&gt; curK &lt;&gt; key) obj</span>：过滤掉对象中与给定键相同的键值对。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">Object filteredPairs</span>：返回更新后的对象。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| key :: remainingPath -&gt;</span>：如果路径有多个键，处理嵌套的对象。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let updatedObj = obj |&gt; List.map ...</span>：更新对象，对每个键值对进行检查和递归处理。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">if curKey = key then (curKey, delAtPath remainingPath value) else (curKey, value)</span>：如果当前键匹配路径上的键，则递归调用 <span style=" font-family:'Courier New';">delAtPath</span>，否则保持键值对不变。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array ele -&gt;</span>：如果 <span style=" font-family:'Courier New';">e</span> 是 <span style=" font-family:'Courier New';">Array</span> 类型，递归地对数组的每个元素调用 <span style=" font-family:'Courier New';">delAtPath</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let delete ps e</span>：定义了 <span style=" font-family:'Courier New';">delete</span> 函数。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">ps |&gt; List.fold ...</span>：对路径列表 <span style=" font-family:'Courier New';">ps</span> 中的每个路径进行处理。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match pathToDel with | [] -&gt; failwith &quot;Cannot delete the root object.&quot;</span>：如果尝试删除根对象（空路径），抛出异常。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| _ -&gt; delAtPath pathToDel curE</span>：对于非空路径，调用 <span style=" font-family:'Courier New';">delAtPath</span> 删除路径上的值。</li></ul></body></div></li><li><h3>List.filter</h3><blockquote><img src = "apd/09e9dc0f3d5a2fd4ecc38d630524ceb8.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=5&x=273&y=318&id=33&uuid=fe6da67323f148d4bdc003d62ff2acae>[P5]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">List.filter</span> 是 F# 中的一个函数，它的作用是对列表进行过滤，返回满足指定条件的元素组成的新列表。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">在给定的列表中，<span style=" font-family:'Courier New';">List.filter</span> 接受一个判定条件的函数，并返回一个新列表，其中只包含原列表中满足条件的元素。在上述代码中，<span style=" font-family:'Courier New';">List.filter (fun (curK, _) -&gt; curK &lt;&gt; key) obj</span> 的作用是从对象 <span style=" font-family:'Courier New';">obj</span> 的键值对列表中过滤掉键等于 <span style=" font-family:'Courier New';">key</span> 的那对键值对，从而得到一个新的键值对列表。</p></body></div></li><li><h3>withPath : Path list -> Ecma -> Ecma list</h3><blockquote><img src = "apd/054aa09cd8204f2752f5a7730bc51278.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=5&x=285&y=620&id=34&uuid=eb49896288a0ef189c488a44dbfd88ce>[P5]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">1错误 选择空路径</p><br/><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p><br/><p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义一个函数来查找给定ECMA表示中指定路径的对象表示。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：沿着指定路径遍历ECMA表示，收集对应的对象表示。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码详解</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec findValAtPath (p : Path) (e : Ecma) : Ecma list</span>：递归地沿路径<span style=" font-family:'Courier New';">p</span>查找ECMA表示<span style=" font-family:'Courier New';">e</span>中的值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let withPath (ps : Path list) (e : Ecma) : Ecma list</span>：使用<span style=" font-family:'Courier New';">findValAtPath</span>函数查找<span style=" font-family:'Courier New';">e</span>中所有指定路径<span style=" font-family:'Courier New';">ps</span>上的对象表示。</li></ul><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></div></li><li><h3>withPath : Path list -> Ecma -> Ecma list</h3><blockquote><img src = "apd/9e0d16de3bc52f6d8339694e091aeb33.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=6&x=300&y=246&id=35&uuid=825dde8dfe510cd92be628738e5150f6>[P6]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec findValAtPath (p : Path) (e : Ecma)</span>：定义了一个递归函数 <span style=" font-family:'Courier New';">findValAtPath</span>，用于查找路径 <span style=" font-family:'Courier New';">p</span> 上的值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match p with</span>：使用模式匹配来检查路径 <span style=" font-family:'Courier New';">p</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| [] -&gt;</span>：如果路径为空，根据 <span style=" font-family:'Courier New';">e</span> 的类型进行处理。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object _ -&gt; [e]</span>：如果是对象，返回对象本身。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array ele -&gt;</span>：如果是数组，递归地处理数组的每个元素。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| headPath :: tailPath -&gt;</span>：如果路径不为空，处理嵌套的对象或数组。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with</span>：使用模式匹配来检查 <span style=" font-family:'Courier New';">e</span> 的类型。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object pairs -&gt;</span>：如果是对象，遍历键值对。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">pairs |&gt; List.collect (fun (key, value) -&gt; ...)</span>：对每个键值对进行处理，递归查找值。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array elements -&gt;</span>：如果是数组，递归地对数组的每个元素调用 <span style=" font-family:'Courier New';">findValAtPath</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let withPath (ps : Path list) (e : Ecma)</span>：定义了 <span style=" font-family:'Courier New';">withPath</span> 函数。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let allPathsInEcma = listPaths e</span>：获取 <span style=" font-family:'Courier New';">e</span> 中所有可能的路径。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let filteredPaths = List.filter ...</span>：过滤出与指定路径列表 <span style=" font-family:'Courier New';">ps</span> 匹配的路径。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">filteredPaths |&gt; List.collect ...</span>：对过滤后的路径使用 <span style=" font-family:'Courier New';">findValAtPath</span> 函数，收集对应的对象表示。</li></ul></body></div></li><li><h3>CW 5 F#版本的JSON 数据结构</h3><blockquote><img src = "apd/769e7cd5c048354a630195d82b9e23d8.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=6&x=298&y=535&id=36&uuid=73ecb53fb99d475ae8c44f02ab9545c3>[P6]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对FSharpON（F#版本的JSON）数据结构的查询、修改和删除操作。通过定义不同的表达式和选择器（selectors），将在FSharpON结构中进行复杂的数据操作</p></body></div></li><li><h3>Task 1 BExpr类型</h3><blockquote><img src = "apd/c7a7c5abf5dcd3436c84c9aa7f227f94.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=10&x=292&y=718&id=38&uuid=247de3c43da481d3ab07bdee05696319>[P10]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义几个<span style=" font-family:'Courier New';">BExpr</span>类型的值和<span style=" font-family:'Courier New';">Selector</span>类型的值，以符合特定的逻辑条件。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">HasKey</span>、<span style=" font-family:'Courier New';">HasStringValue</span>等构造器在<span style=" font-family:'Courier New';">BExpr</span>类型中表示特定的逻辑条件。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">Match</span>、<span style=" font-family:'Courier New';">Sequence</span>、<span style=" font-family:'Courier New';">OneOrMore</span>等构造器在<span style=" font-family:'Courier New';">Selector</span>类型中定义如何从FSharpON结构中选择数据。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码功能</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">b1</span>、<span style=" font-family:'Courier New';">b2</span>、<span style=" font-family:'Courier New';">b3</span>：根据特定的条件（如键的存在、数值范围、字符串值等）来构造布尔表达式。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">s1</span>、<span style=" font-family:'Courier New';">s2</span>、<span style=" font-family:'Courier New';">s3</span>：定义了选择数据的复杂规则，例如选择特定深度或满足某些条件的数据。</li></ul></body></div></li><li><h3>let b1 = And(HasKey "blue", And(HasKey "left", Not(HasKey "red")))</h3><blockquote><img src = "apd/a5665826d76f01a0d73c87707e33a88a.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=11&x=243&y=176&id=40&uuid=522d4b6149e1094f4ed2490be9853da4>[P11]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">And(HasKey &quot;blue&quot;, And(HasKey &quot;left&quot;, Not(HasKey &quot;red&quot;)))</span>: 这个表达式表示一个组合条件。</p><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">HasKey &quot;blue&quot;</span>: 检查Ecma对象是否有一个键为&quot;blue&quot;的项。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">HasKey &quot;left&quot;</span>: 检查Ecma对象是否有一个键为&quot;left&quot;的项。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">Not(HasKey &quot;red&quot;)</span>: 检查Ecma对象是否没有一个键为&quot;red&quot;的项。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">And</span>: 将这些条件组合在一起，确保所有这些条件都得到满足</li></ul></body></div></li><li><h3>Task 2 eval函数 布尔值</h3><blockquote><img src = "apd/d6083dd4b8154009f25b08a3d3c41a66.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=11&x=302&y=439&id=41&uuid=5272c4adc864e2cb6c506ea4eb2eb449>[P11]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义<span style=" font-family:'Courier New';">eval</span>函数，用于计算<span style=" font-family:'Courier New';">BExpr</span>表达式在给定的<span style=" font-family:'Courier New';">Ecma</span>数据上的布尔值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">根据<span style=" font-family:'Courier New';">BExpr</span>表达式的不同情况，递归地计算其在<span style=" font-family:'Courier New';">Ecma</span>数据上的布尔值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">针对<span style=" font-family:'Courier New';">Ecma</span>数据的不同类型（如对象、数组、字符串等）进行条件判断。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码功能</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">根据<span style=" font-family:'Courier New';">BExpr</span>的构造器（如<span style=" font-family:'Courier New';">Not</span>、<span style=" font-family:'Courier New';">And</span>、<span style=" font-family:'Courier New';">HasKey</span>等）对<span style=" font-family:'Courier New';">Ecma</span>数据进行评估，并返回布尔值。</li></ul></body></div></li><li><h3>HasKey k</h3><blockquote><img src = "apd/2f8f5a4fb246202bb8da0232c8578954.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=12&x=248&y=182&id=42&uuid=7fa7c78e94e1ea0bd5cae991504b3955>[P12]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">HasKey k</span>：当<span style=" font-family:'Courier New';">BExpr</span>是<span style=" font-family:'Courier New';">HasKey k</span>且<span style=" font-family:'Courier New';">Ecma</span>值是一个对象时，函数检查该对象是否包含键<span style=" font-family:'Courier New';">k</span>。这通过遍历对象的键值对列表并检查是否存在键等于<span style=" font-family:'Courier New';">k</span>的元素来实现。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">HasKey k</span>：如果<span style=" font-family:'Courier New';">Ecma</span>值不是对象，函数返回<span style=" font-family:'Courier New';">false</span>，因为非对象类型的<span style=" font-family:'Courier New';">Ecma</span>值不包含键。</li></ol></body></div></li><li><h3>HasStringValue s</h3><blockquote><img src = "apd/1f42765f95d4b2762ea84230254c89af.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=12&x=300&y=273&id=43&uuid=91b3806b3e4f1338160dea99aa985a4e>[P12]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">HasStringValue s</span>：如果<span style=" font-family:'Courier New';">Ecma</span>值是对象，函数遍历对象的键值对，检查是否有任何值是字符串且等于<span style=" font-family:'Courier New';">s</span>。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">HasStringValue s</span>：如果<span style=" font-family:'Courier New';">Ecma</span>值是数组，函数类似地遍历数组的元素，检查是否有元素是字符串且等于<span style=" font-family:'Courier New';">s</span>。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">HasStringValue s</span>：对于其他类型的<span style=" font-family:'Courier New';">Ecma</span>值，由于它们不是字符串，函数返回<span style=" font-family:'Courier New';">false</span>。</li></ol></body></div></li><li><h3>Task 3 Select</h3><blockquote><img src = "apd/dab80ad6522279aba390ceb7a9e44ab4.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=13&x=298&y=297&id=44&uuid=ae130526dd96fc760ee5912da404cac7>[P13]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">目标</span>：定义<span style=" font-family:'Courier New';">select</span>函数，根据<span style=" font-family:'Courier New';">Selector</span>在<span style=" font-family:'Courier New';">Ecma</span>数据结构中选择数据。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">在<span style=" font-family:'Courier New';">Ecma</span>结构中遍历，根据<span style=" font-family:'Courier New';">Selector</span>的定义选择数据。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对于对象和数组类型的数据，递归地处理其子元素。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码功能</span>：</li></ul><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">根据<span style=" font-family:'Courier New';">Selector</span>选择<span style=" font-family:'Courier New';">Ecma</span>结构中的数据，同时收集数据的路径信息。</li></ul></body></div></li><li><h3>matchWithChildren 辅助函数</h3><blockquote><img src = "apd/d4a1d346262901dc9e544ecd866cb2a0.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=14&x=180&y=93&id=45&uuid=59c48fda1c2bd39042316f6368f09b98>[P14]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h3 style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:large; font-weight:600;">matchWithChildren</span><span style=" font-size:large; font-weight:600;"> 辅助函数</span></h3><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let rec matchWithChildren s e path = ...</span>：这是一个辅助函数，用于处理<span style=" font-family:'Courier New';">Ecma</span>结构中的对象（<span style=" font-family:'Courier New';">Object</span>）和数组（<span style=" font-family:'Courier New';">Array</span>）。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">match e with ...</span>：这里使用模式匹配来处理不同类型的<span style=" font-family:'Courier New';">Ecma</span>值。</li></ul></body></div></li><li><h3>对于Object类型</h3><blockquote><img src = "apd/12487d2debf212c2a89e374147733b20.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=14&x=312&y=129&id=46&uuid=20386489f6d81b4c96592fb783c98943>[P14]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h4 style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">对于</span><span style=" font-family:'Courier New'; font-size:medium; font-weight:600;">Object</span><span style=" font-size:medium; font-weight:600;">类型</span></h4><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Object fields -&gt; fields |&gt; List.collect (fun (k, v) -&gt; selectHelper s v (path @ [Key k]))</span>：如果<span style=" font-family:'Courier New';">Ecma</span>是一个对象，函数遍历对象中的所有字段。对于每个字段，它使用<span style=" font-family:'Courier New';">selectHelper</span>来处理字段值，并更新路径来包含当前字段的键。</li></ul></body></div></li><li><h3>对于Array类型</h3><blockquote><img src = "apd/73f13378a914dfb6e766161d827214c8.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=14&x=292&y=161&id=47&uuid=6c9ed0e5cdbf0c71485eee3c41ba05c5>[P14]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h4 style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">对于</span><span style=" font-family:'Courier New'; font-size:medium; font-weight:600;">Array</span><span style=" font-size:medium; font-weight:600;">类型</span></h4><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">| Array elements -&gt; elements |&gt; List.mapi (fun i v -&gt; selectHelper s v (path @ [Index i])) |&gt; List.collect id</span>：如果<span style=" font-family:'Courier New';">Ecma</span>是一个数组，函数对数组中的每个元素执行类似的操作，更新路径来包含元素的索引。</li></ul></body></div></li><li><h3>List.mapi</h3><blockquote><img src = "apd/d5e96540b24ed7a5f404891f3c51de4c.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=14&x=354&y=160&id=48&uuid=caa0c23e24ae920bae8c693775fe7e09>[P14]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">List.mapi</span> 是 F# 中的一个函数，它用于对列表中的每个元素应用一个函数，并且这个函数可以使用元素的索引。<span style=" font-family:'Courier New';">List.mapi</span> 的行为类似于 <span style=" font-family:'Courier New';">List.map</span>，但它提供了两个参数给应用的函数：元素的索引（从 0 开始）和元素本身。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">简单来说，如果你有一个列表 <span style=" font-family:'Courier New';">[a; b; c; ...]</span>，并且你使用 <span style=" font-family:'Courier New';">List.mapi</span> 应用函数 <span style=" font-family:'Courier New';">f</span> 到这个列表，那么结果将是一个新列表，其中第一个元素是 <span style=" font-family:'Courier New';">f 0 a</span>（即使用索引 0 和元素 <span style=" font-family:'Courier New';">a</span> 调用 <span style=" font-family:'Courier New';">f</span>）</p></body></div></li><li><h3>Task 4 </h3><blockquote><img src = "apd/e5b79733a92c7ed0bac212845c60911b.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=14&x=249&y=561&id=49&uuid=3eb936fd01679a3f69de14368ebdb87c>[P14]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现需求</span>：实现一个<span style=" font-family:'Courier New';">update</span>函数，用于更新FsharpON数据中特定元素的值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">select</span>函数找到需要更新的元素。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">应用提供的更新规则（对字符串和浮点数的函数）来修改这些元素。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：此函数用于根据特定规则更新FsharpON数据结构中的元素。</li></ol></body></div></li><li><h3>doUpdate</h3><blockquote><img src = "apd/ae94a9e817a770bfe3749cceca9d83e7.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=15&x=311&y=252&id=50&uuid=fce873e8ad3c80d13e4bad6a029b6198>[P15]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h3 style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">函数 </span><span style=" font-family:'Courier New'; font-size:large; font-weight:600;">doUpdate</span></h3><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">这个递归函数负责进行实际的更新操作。它遍历FsharpON数据结构，并根据选择器选中的元素来更新值。</p><br/><h4 style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">参数</span></h4><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">su</span>: 一个函数，用于更新字符串值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">nu</span>: 一个函数，用于更新浮点数值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">selected</span>: 一个包含路径和元素的列表，这些元素是根据选择器从FsharpON数据结构中选出来的。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">e</span>: 当前正在处理的FsharpON元素。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">path</span>: 当前元素在数据结构中的路径。</li></ul><br/><h4 style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">逻辑</span></h4><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">匹配对象 (</span><span style=" font-family:'Courier New'; font-weight:600;">Object obj</span><span style=" font-weight:600;">)</span>: 如果当前元素是一个对象，那么遍历对象中的每一个键值对。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果当前键值对的路径在<span style=" font-family:'Courier New';">selected</span>列表中，那么应用<span style=" font-family:'Courier New';">su</span>和<span style=" font-family:'Courier New';">nu</span>函数来更新这个值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">否则，递归调用<span style=" font-family:'Courier New';">doUpdate</span>来处理这个键值对的值。</li></ul><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">匹配数组 (</span><span style=" font-family:'Courier New'; font-weight:600;">Array ele</span><span style=" font-weight:600;">)</span>: 如果当前元素是一个数组，那么遍历数组中的每一个元素。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果当前元素的索引在<span style=" font-family:'Courier New';">selected</span>列表中，那么应用<span style=" font-family:'Courier New';">su</span>和<span style=" font-family:'Courier New';">nu</span>函数来更新这个元素。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">否则，递归调用<span style=" font-family:'Courier New';">doUpdate</span>来处理这个数组元素。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">其他情况</span>: 直接应用<span style=" font-family:'Courier New';">su</span>和<span style=" font-family:'Courier New';">nu</span>函数来更新当前元素。</li></ul><br/><h3 style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">选择要更新的元素</span></h3><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let selected = select s e</span>: 使用<span style=" font-family:'Courier New';">select</span>函数和提供的选择器<span style=" font-family:'Courier New';">s</span>来找出要更新的元素。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">let uniqueSelected = selected |&gt; List.distinctBy fst</span>: 确保选出的元素是唯一的，避免重复处理。</li></ul></body></div></li><li><h3>调用 doUpdate</h3><blockquote><img src = "apd/8343909d75ea1a13fc8fe2cd59d3e42e.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=15&x=191&y=422&id=51&uuid=767e74d5e4888ad8580b5830742239fd>[P15]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h3 style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">调用 </span><span style=" font-family:'Courier New'; font-size:large; font-weight:600;">doUpdate</span></h3><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">doUpdate su nu uniqueSelected e []</span>: 从根元素开始，使用<span style=" font-family:'Courier New';">doUpdate</span>函数来更新数据结构中的元素。</li></ul><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">总结来说，这段代码的目的是根据提供的选择器来查找FsharpON数据结构中需要更新的元素，然后使用提供的函数来更新这些元素的值。这个更新过程是递归进行的，确保整个数据结构中的所有相关元素都被适当地更新。</p></body></div></li><li><h3>Task 5 delete</h3><blockquote><img src = "apd/4b09bb68b5940b716c047d95bd73b485.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=15&x=294&y=567&id=52&uuid=c14f588ab0113ab0d8e8be9e047907e3>[P15]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现需求</span>：定义<span style=" font-family:'Courier New';">delete</span>函数，用于删除FsharpON数据中符合特定选择器条件的元素。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">select</span>函数找到要删除的元素。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">从FsharpON数据结构中移除这些元素及其子树。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：此函数用于从FsharpON数据结构中删除特定元素。</li></ol></body></div></li><li><h3>Task 6 toZerro truncate</h3><blockquote><img src = "apd/0a70f96c95f3dd0e166f308d40554153.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=15&x=293&y=942&id=53&uuid=05a170912b1096dcef2eba0d0070113d>[P15]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><h4 style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:medium; font-weight:600;">任务 6</span></h4><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现需求</span>：定义<span style=" font-family:'Courier New';">toZero</span>和<span style=" font-family:'Courier New';">truncate</span>函数，分别用于将FsharpON数据中的数值归零和截断字符串。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">利用<span style=" font-family:'Courier New';">update</span>函数来实现这两个操作。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">toZero</span>将指定范围内的数值设置为0，<span style=" font-family:'Courier New';">truncate</span>将字符串截断到指定长度。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：这两个函数用于特定条件下修改FsharpON数据结构中的数值或字符串。</li></ol></body></div></li><li><h3>Task 7 mapEcma</h3><blockquote><img src = "apd/d41072ecab72e4135934bf7154619f1b.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=16&x=296&y=771&id=55&uuid=0b37743579c66a7b015a304d823ac141>[P16]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">实现需求</span>：定义<span style=" font-family:'Courier New';">mapEcma</span>函数，用于更新FsharpON数据结构中的所有值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">使用<span style=" font-family:'Courier New';">update</span>函数，配合将所有值都选中的选择器。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">应用给定的字符串和浮点数的函数来更新所有值。</li></ul><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：此函数用于应用全局更新规则到FsharpON数据结构的每个元素上。</li></ol></body></div></li><li><blockquote><p>Coursework 6 Tail Recursion <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=17&x=137&y=266&id=57&uuid=d8d19eee990a184f8bd44fad3e425fc3>[P17]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">F#中的尾递归（Tail Recursion）是一种特殊的递归方法，其中递归调用是函数体中的最后一个操作。在尾递归中，函数返回的结果直接是对自己的递归调用，而不是首先对递归调用的结果进行进一步的处理。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">尾递归的优点是它允许编译器或解释器进行优化，通过所谓的尾调用优化（Tail Call Optimization, TCO），将递归转换为迭代。这意味着函数在递归调用时不需要维持当前的调用栈帧，因为所有的局部变量和计算状态都不再需要。结果是，尾递归函数即使在处理大量递归调用时也不会导致栈溢出，这使得它在处理大型数据结构和复杂算法时非常有用。</p><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">简而言之，尾递归是一种编写递归函数的方式，可以避免栈溢出，并且通常比普通递归更高效。</p></body></div></li><li><h3>Task 1 Not any in list</h3><blockquote><img src = "apd/3a61cdd9911cf0297d3d2fc793445c44.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=17&x=293&y=424&id=58&uuid=93604977ad8e433ef1b35617f772a537>[P17]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">问题描述</span>：编写一个函数 <span style=" font-family:'Courier New';">notAnyInList</span>，它接受一个函数作为谓词和一个整数与浮点数对的列表，返回一个布尔值，表示这个谓词是否对列表中的任何元素都不成立。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：使用尾递归遍历列表，检查每个元素是否满足谓词。如果有任何一个元素满足谓词，则立即返回 <span style=" font-family:'Courier New';">false</span>；如果列表为空或所有元素都不满足谓词，则返回 <span style=" font-family:'Courier New';">true</span>。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：这段代码定义了一个递归函数 <span style=" font-family:'Courier New';">checkPairs</span> 来逐个检查列表中的元素，并在发现谓词成立的元素时返回 <span style=" font-family:'Courier New';">false</span>，否则继续递归。如果遍历完整个列表没有找到满足条件的元素，则返回 <span style=" font-family:'Courier New';">true</span>。</li></ol></body></div></li><li><h3>notAnyInList : (int -> float -> bool) -> (int * float) list -> bool</h3><blockquote><img src = "apd/63e201769e1f9b5b18416222e566c445.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=17&x=254&y=629&id=59&uuid=fcf78b16afa41defc0c6f9abba09df39>[P17]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">函数定义</span>：<span style=" font-family:'Courier New';">notAnyInList</span> 函数接受两个参数，一个是谓词函数 <span style=" font-family:'Courier New';">predicate</span>（接受一个 <span style=" font-family:'Courier New';">int</span> 和一个 <span style=" font-family:'Courier New';">float</span> 并返回一个 <span style=" font-family:'Courier New';">bool</span>），另一个是一个元组列表 <span style=" font-family:'Courier New';">lst</span>（每个元组包含一个 <span style=" font-family:'Courier New';">int</span> 和一个 <span style=" font-family:'Courier New';">float</span>）。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">尾递归函数 </span><span style=" font-family:'Courier New'; font-weight:600;">checkPairs</span>：这是一个内部函数，用于递归地检查列表中的每一对元素。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">当 <span style=" font-family:'Courier New';">pairs</span> 为空列表 <span style=" font-family:'Courier New';">[]</span> 时，返回 <span style=" font-family:'Courier New';">true</span>。这意味着列表中没有任何元素满足谓词条件。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">当 <span style=" font-family:'Courier New';">pairs</span> 为 <span style=" font-family:'Courier New';">(x, y)::rest</span> 形式时，即列表中至少有一个元素 <span style=" font-family:'Courier New';">(x, y)</span>，函数检查谓词 <span style=" font-family:'Courier New';">predicate x y</span> 是否为 <span style=" font-family:'Courier New';">true</span>。如果是，返回 <span style=" font-family:'Courier New';">false</span>（表示找到了一个满足谓词的元素），否则递归调用 <span style=" font-family:'Courier New';">checkPairs</span> 继续检查剩余的元素。</li></ul><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">结果</span>：调用 <span style=" font-family:'Courier New';">checkPairs</span> 函数并传递 <span style=" font-family:'Courier New';">lst</span> 作为参数。这个函数最终返回一个布尔值，表示谓词是否对列表中任何元素都不成立。</li></ol></body></div></li><li><h3>Task 2 add head as last element if</h3><blockquote><img src = "apd/eb059e8be6c9b28a0202aa17f2c0d28f.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=17&x=294&y=1032&id=62&uuid=61c370917d95bb3024bd65c4b6102c29>[P17]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">问题描述</span>：实现一个函数 <span style=" font-family:'Courier New';">addHeadAsLastElementIf</span>，这个函数处理一个列表的列表，根据给定的谓词条件，将每个子列表的头元素（如果存在）添加到其尾部。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：使用递归遍历整个列表的列表。对于每个子列表，检查其头元素是否满足谓词条件。如果满足，则将头元素添加到列表尾部。处理空列表时，使用先前的元素或默认值。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：这段代码首先定义了一个递归函数 <span style=" font-family:'Courier New';">processLists</span>，用于遍历和处理每个子列表。它根据谓词条件和当前处理的元素来更新每个子列表，并在必要时添加元素。</li></ol></body></div></li><li><h3>addHeadAsLastElementIf 0 (fun _ -> true) [[1;2;3];[]]</h3><blockquote><img src = "apd/1758ff5241b726b3f48374b6c21ee1d0.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=18&x=244&y=634&id=64&uuid=7a57a1e31e399fc329490cd07355ed4e>[P18]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">函数定义</span>：<span style=" font-family:'Courier New';">addHeadAsLastElementIf</span> 函数接受三个参数：一个默认值 <span style=" font-family:'Courier New';">defaultVal</span>，一个谓词函数 <span style=" font-family:'Courier New';">predicate</span>，以及一个列表的列表 <span style=" font-family:'Courier New';">listOfLists</span>。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">尾递归函数 </span><span style=" font-family:'Courier New'; font-weight:600;">processLists</span>：这是一个内部函数，用于递归地处理列表的列表。</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果 <span style=" font-family:'Courier New';">listOfLists</span> 为空，返回累积的结果 <span style=" font-family:'Courier New';">acc</span> 的逆序（因为在递归过程中元素被添加到了 <span style=" font-family:'Courier New';">acc</span> 的前面）。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对于非空 <span style=" font-family:'Courier New';">listOfLists</span>（形式为 <span style=" font-family:'Courier New';">head::tail</span>），函数处理当前头部列表 <span style=" font-family:'Courier New';">head</span> 并更新累积器 <span style=" font-family:'Courier New';">acc</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">在处理 <span style=" font-family:'Courier New';">head</span> 时，根据其内容和谓词条件更新 <span style=" font-family:'Courier New';">newElement</span> 和 <span style=" font-family:'Courier New';">newList</span>，然后递归调用 <span style=" font-family:'Courier New';">processLists</span>。</li></ul><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">结果</span>：调用 <span style=" font-family:'Courier New';">processLists</span> 函数并传递 <span style=" font-family:'Courier New';">defaultVal</span>、空列表 <span style=" font-family:'Courier New';">[]</span> 和 <span style=" font-family:'Courier New';">listOfLists</span> 作为参数。这个函数最终返回一个更新后的列表的列表。</li></ol></body></div></li><li><h3>Task 3 使用List.fold完成Task 2</h3><blockquote><img src = "apd/9bf066968400009730da01bd68e6930a.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=19&x=291&y=184&id=65&uuid=05f02d52057b34583a9ab14352c1a625>[P19]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">问题描述</span>：与任务 2 类似，但要求使用 <span style=" font-family:'Courier New';">List.fold</span> 或 <span style=" font-family:'Courier New';">List.foldBack</span> 实现。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：使用 <span style=" font-family:'Courier New';">List.fold</span> 函数来遍历列表的列表，累积一个结果列表，同时保持跟踪上一个处理的元素。对于每个子列表，根据谓词条件进行相应处理。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：这段代码利用 <span style=" font-family:'Courier New';">fold</span> 函数来累积结果，并在遍历的过程中根据谓词条件更新每个子列表。它为每个非空子列表添加头元素到尾部，或者为空列表添加先前元素或默认值。</li></ol></body></div></li><li><h3>addHeadAsLastElementIfFold : 'a -> ('a -> bool) -> 'a list list -> 'a list list</h3><blockquote><img src = "apd/86df4a301f50e7dc71fb5049c9e3c629.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=19&x=259&y=391&id=66&uuid=820b8cd7dd0fa77257b58c2769eca312>[P19]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">函数定义</span>：<span style=" font-family:'Courier New';">addHeadAsLastElementIfFold</span> 采用 <span style=" font-family:'Courier New';">List.fold</span> 来实现功能，类似于任务 2，但使用的是折叠（fold）技术。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">使用 </span><span style=" font-family:'Courier New'; font-weight:600;">List.fold</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">List.fold</span> 函数遍历 <span style=" font-family:'Courier New';">listLists</span>，累积结果到 <span style=" font-family:'Courier New';">acc</span>，同时维护一个“前一个元素” <span style=" font-family:'Courier New';">prevElem</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对于每个子列表 <span style=" font-family:'Courier New';">curList</span>，根据其内容和谓词条件更新累积器 <span style=" font-family:'Courier New';">acc</span> 和 <span style=" font-family:'Courier New';">prevElem</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">如果 <span style=" font-family:'Courier New';">curList</span> 为空且 <span style=" font-family:'Courier New';">prevElem</span> 满足谓词，将 <span style=" font-family:'Courier New';">prevElem</span> 添加到 <span style=" font-family:'Courier New';">acc</span>。如果 <span style=" font-family:'Courier New';">curList</span> 的头元素满足谓词，将其添加到 <span style=" font-family:'Courier New';">curList</span> 的尾部并更新 <span style=" font-family:'Courier New';">acc</span>。</li></ul><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">结果</span>：折叠操作完成后，<span style=" font-family:'Courier New';">helper</span> 包含了最终的结果，但是逆序的，所以需要用 <span style=" font-family:'Courier New';">List.rev</span> 将其反转。</li></ol></body></div></li><li><h3>Task 4 
maxAndMax2InTree，找出一个树型数据结构中的最大值和次大值。</h3><blockquote><img src = "apd/2c0745027e7570d7287aa66e71dad6e1.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=19&x=296&y=739&id=67&uuid=dbc3331bc5b003f692697908497822ca>[P19]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">问题描述</span>：编写一个函数 <span style=" font-family:'Courier New';">maxAndMax2InTree</span>，找出一个树型数据结构中的最大值和次大值。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">编码思路</span>：使用续延传递风格来遍历树。递归地处理每个分支，并使用一个续延函数来计算和比较左右分支的最大值和次大值。</li><br/><li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">代码作用</span>：这段代码通过递归遍历树的每个节点，使用续延函数来维护和更新最大值和次大值。它能够高效地找出树中的最大值和次大值，即使树结构非常复杂。</li></ol></body></div></li><li><h3>maxAndMax2InTree : int Tree -> int * int</h3><blockquote><img src = "apd/beaea5b786c27caafc05c1ee7d9c6146.png"> <a href=bookxnotepro://opennote/?nb={36f39b7c-aa0c-4cf3-9ca6-17b74914adf9}&book=0e37d5aaf4f42b7873909c8361f95b4b&page=20&x=308&y=257&id=69&uuid=939de691f2d87d3f6af12c6095c68066>[P20]</a></blockquote><div class="annot"><body style=" font-family:'Microsoft Tai Le'; font-size:8pt; font-weight:400; font-style:normal;"><br/><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">函数定义</span>：<span style=" font-family:'Courier New';">maxAndMax2InTree</span> 接受一个 <span style=" font-family:'Courier New';">int Tree</span> 类型的树，并返回一个包含两个整数的元组（最大值和次大值）。</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">续延函数 </span><span style=" font-family:'Courier New'; font-weight:600;">max2Helper</span>：</li><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 2;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对于 <span style=" font-family:'Courier New';">El(value)</span>，即树的叶子节点，直接使用续延 <span style=" font-family:'Courier New';">cont</span>，将当前值和 <span style=" font-family:'Courier New';">int</span> 的最小值作为参数传递给 <span style=" font-family:'Courier New';">cont</span>。</li><br/><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">对于 <span style=" font-family:'Courier New';">Br(left, right)</span>，即树的分支节点，递归地处理左子树和右子树，并使用续延将计算结果传递下去。左右子树的最大值和次大值被排序，然后传递给 <span style=" font-family:'Courier New';">cont</span>。</li></ul><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">结果</span>：函数首先检查 <span style=" font-family:'Courier New';">tree</span> 是否为单一元素的树。如果是，直接返回该元素和 <span style=" font-family:'Courier New';">int</span> 的最小值。否则，调用 <span style=" font-family:'Courier New';">max2Helper</span> 并提供一个续延函数来处理结果。最终返回树中的最大值和次大值。</li></ol></body></div></li></ul>
<footer><div style = "background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div>
<div style = "text-align:center; "><a target="_blank" href="http://www.bookxnote.com">&copy2018-2023 BookxNote</a></div></footer>
</body>
</html>
